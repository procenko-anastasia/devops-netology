# Домашнее задание к занятию "6.6. Troubleshooting"
## Проценко Анастасия

## Задача 1

*Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).*

*Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать.* 

*Вы как инженер поддержки решили произвести данную операцию:*

1. Поиск операций, время выполнения которых превысило 3 минуты (180 сек)

```
db.currentOp().inprog.forEach(
  function(op) {
    if(op.secs_running > 180) printjson(op);
  }
)
```

2. Убиваем подвисший запрос
```
db.killOp(<opid>)
```

- *предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB*

```
db.runCommand( { distinct: "collection",
                 key: "city",
                 maxTimeMS: 45 } )
```

## Задача 2

*Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).*

*Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса.* 

*При масштабировании сервиса до N реплик вы увидели, что:*
- *сначала рост отношения записанных значений к истекшим*
- *Redis блокирует операции записи*

*Как вы думаете, в чем может быть проблема?*

1. Читаем логи на предмет ошибок конфигурации и подсказок по их устранению.

2. Смотрим метрики.

3. Проверяем размер хранилища Redis и память под хранилище.

4. Ищем какие операции, запущенные на Redis, могли повлиять на работу сервиса.


## Задача 3

*Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).*

*Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:*
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

*Как вы думаете, почему это начало происходить и как локализовать проблему?*

*Какие пути решения данной проблемы вы можете предложить?*

1. Смотрим логи

2. Идёт запрос слишком большого BLOB'а.  
То есть, надо увеличивать `max_allowed_packet`
 
3. Тайм-аут во время обработки запроса.  
Надо увеличить допустимые тайм-ауты в настройках сервера - `net_read_timeout`, `connect_timeout`.  

## Задача 4

*Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.*

*Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.*

*После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:*

`postmaster invoked oom-killer`

*Как вы думаете, что происходит?*

**Postgres-e `postmaster` съел слишком много памяти, поэтому его убил `oom-killer`**

*Как бы вы решили данную проблему?*
___
***1 вариант.*** 

Модифицировать параметр процесса СУБД `oom_score_adj`
Механизм OOM-killer для каждого процесса подсчитывает некие `oom-scores`, процесс с наибольшим количеством `oom-scores` становится кандидатом на завершение. Для уменьшения `oom-scores` процесса и, как следствие, вероятности завершения процесса, предлагается присвоить большое отрицательное значение параметру `oom_score_adj`.

Определим PID процесса СУБД:
```
postgres=# SELECT pg_backend_pid();
pg_backend_pid 
----------------
   <PID> 
(1 row)
```

Можно посмотреть текущее значение oom-scores процесса:
```
sudo cat /proc/<PID>/oom_score  
```

Присвоить большое отрицательное значение (уменьшить итоговое значение oom_score)

```
sudo echo -100 > /proc/<PID>/oom_score_adj
```

По оптимизации использования памяти Postgres предлагается настроить следующие параметры файла конфигурации postgresql.conf:

```hared_buffers``` определяет количество ОЗУ для хранения кэшированных данных, характерный размер указан 15%-25% от максимального размера ОЗУ;

```work_mem``` определяет количество ОЗУ, используемое для внутренних операций сортировки и хэширования, значение по умолчанию 4 Мб;

```maintenance_work_mem``` определяет количество ОЗУ, используемое при операциях сопровождения (maintenance), размер по умолчанию 64 Мб;

```effective_cache_size``` опредяляет количество ОЗУ, используемое дисковым кэшем СУБД, рекомедованный размер 50% от максимального размера ОЗУ.


Тогда для уменьшения размера потребляемой СУБД ОЗУ, в порядке приоритета, нужно уменьшить значения параметра ```effective_cache_size```, затем ```shared_buffers```. Типичные значения параметров work_mem и maintenance_work_mem, по-видимому, пренебрежимо малы по сравнению с типичным размером ОЗУ сервера.
___
***2 вариант.***

 Выставить переменную ядра `vm.overcommit_memory` в значение, равное `2`. В этом случае ядро не будет резервировать больше памяти, чем указано в параметре `overcommit_ratio`**. 
